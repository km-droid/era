
package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
)

var (
	gitModuleRe = regexp.MustCompile(`(?m)source\s*=\s*\"git::https://github.com/[^/]+/modules\.git//([^"?]+)(\?ref=[^\"]+)?\"`)
	moduleSourceRe = regexp.MustCompile(`(?m)source\s*=\s*\"registry\.terraform\.example\.com/org/([^/]+)/google\"`)
	moduleBlockRe  = regexp.MustCompile(`(?ms)(module\s+\"[^\"]+\"\s*\{[^}]*?source\s*=\s*\"registry\.terraform\.example\.com/org/[^\"]+/google\"[^}]*?)version\s*=\s*\"[^\"]+\"([^}]*?})`)
	updatedFiles []string
	mu sync.Mutex
	dryRun    bool
	showHelp  bool
	migrateMode bool
	updateMode  bool
)

func cloneRepo(repoName string) error {
	repoURL := fmt.Sprintf("git@github.com:your-org/%s.git", repoName)
	cmd := exec.Command("git", "clone", repoURL)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func collectTfFiles(repoPath string) ([]string, error) {
	var tfFiles []string
	err := filepath.WalkDir(repoPath, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(d.Name(), ".tf") {
			tfFiles = append(tfFiles, path)
		}
		return nil
	})
	return tfFiles, err
}

func transformGitSourceToRegistry(content string, versionConstraint string) string {
	lines := strings.Split(content, "\n")
	for i, line := range lines {
		matches := gitModuleRe.FindStringSubmatch(line)
		if matches != nil {
			moduleName := matches[1]
			sourceLine := fmt.Sprintf("  source  = \"registry.terraform.example.com/org/%s/google\"", moduleName)
			versionLine := fmt.Sprintf("  version = \"%s\"", versionConstraint)
			lines[i] = sourceLine + "\n" + versionLine
		}
	}
	return strings.Join(lines, "\n")
}

func updateModuleVersion(content string, versionConstraint string) string {
	if migrateMode {
		content = transformGitSourceToRegistry(content, versionConstraint)
	}
	if moduleBlockRe.MatchString(content) {
		return moduleBlockRe.ReplaceAllString(content, `$1version = ""`+versionConstraint+`"$2`)
	}
	lines := strings.Split(content, "\n")
	for i, line := range lines {
		matches := moduleSourceRe.FindStringSubmatch(line)
		if matches != nil {
			versionLine := fmt.Sprintf("  version = \"%s\"", versionConstraint)
			lines[i] = line + "\n" + versionLine
		}
	}
	return strings.Join(lines, "\n")
}

func processFile(path string, versionConstraint string, wg *sync.WaitGroup) {
	defer wg.Done()
	input, err := ioutil.ReadFile(path)
	if err != nil {
		fmt.Printf("‚ùå Failed to read %s: %v\n", path, err)
		return
	}
	content := string(input)
	updated := updateModuleVersion(content, versionConstraint)
	if updated != content {
		if dryRun {
			fmt.Printf("üîç Would update: %s\n", path)
		} else {
			err := ioutil.WriteFile(path, []byte(updated), 0644)
			if err != nil {
				fmt.Printf("‚ùå Failed to write %s: %v\n", path, err)
				return
			}
			fmt.Printf("‚úÖ Updated: %s\n", path)
			mu.Lock()
			updatedFiles = append(updatedFiles, path)
			mu.Unlock()
		}
	}
}

func updateModulesConcurrently(repoPath string, versionConstraint string) error {
	tfFiles, err := collectTfFiles(repoPath)
	if err != nil {
		return err
	}
	var wg sync.WaitGroup
	sem := make(chan struct{}, 8)
	for _, path := range tfFiles {
		wg.Add(1)
		sem <- struct{}{}
		go func(p string) {
			defer func() { <-sem }()
			processFile(p, versionConstraint, &wg)
		}(path)
	}
	wg.Wait()
	return nil
}

func createPR(repoName, branchName string) (string, error) {
	repoDir := filepath.Base(repoName)
	if err := os.Chdir(repoDir); err != nil {
		return "", err
	}
	cmds := [][]string{
		{"git", "checkout", "-b", branchName},
		{"git", "add", "."},
		{"git", "commit", "-m", "Update Terraform module version constraints"},
		{"git", "push", "--set-upstream", "origin", branchName},
	}
	for _, args := range cmds {
		cmd := exec.Command(args[0], args[1:]...)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			return "", err
		}
	}
	prURL := fmt.Sprintf("https://github.com/your-org/%s/compare/main...%s", repoName, branchName)
	return prURL, nil
}

func printUsage() {
	fmt.Println("Usage: terraform-module-migrator [options] <repo-name>")
	fmt.Println("\nArguments:")
	fmt.Println("  <repo-name>\tGitHub repository name (required)")
	fmt.Println("\nOptions:")
	fmt.Println("  --dry-run\t\tPreview changes without modifying files")
	fmt.Println("  --version=<v>\tModule version constraint (e.g., 2.0 or ~> 2.0)")
	fmt.Println("  --migrate-to-jfrog\tConvert Git-based modules to registry")
	fmt.Println("  --update-jfrog-version\tUpdate version for already-migrated registry modules")
	fmt.Println("  --help\t\tShow this help message")
}

func main() {
	var moduleVersionRaw string
	flag.BoolVar(&dryRun, "dry-run", false, "Preview changes without modifying files")
	flag.BoolVar(&showHelp, "help", false, "Show help message")
	flag.BoolVar(&migrateMode, "migrate-to-jfrog", false, "Migrate Git modules to JFrog registry")
	flag.BoolVar(&updateMode, "update-jfrog-version", false, "Update version for existing JFrog modules")
	flag.StringVar(&moduleVersionRaw, "version", "", "Module version constraint (e.g., 2.0 or ~> 2.0)")
	flag.Parse()

	if showHelp || flag.NArg() < 1 {
		printUsage()
		os.Exit(0)
	}

	if !migrateMode && !updateMode {
		fmt.Println("‚ùå You must specify either --migrate-to-jfrog or --update-jfrog-version")
		printUsage()
		os.Exit(1)
	}

	if updateMode && moduleVersionRaw == "" {
		fmt.Println("‚ùå --version is required when using --update-jfrog-version")
		os.Exit(1)
	}

	repo := flag.Arg(0)
	versionConstraint := moduleVersionRaw
	if versionConstraint != "" && !strings.HasPrefix(versionConstraint, "~") {
		versionConstraint = fmt.Sprintf("~> %s", moduleVersionRaw)
	}

	branch := "update-jfrog-version"
	if migrateMode {
		branch = "migrate-to-jfrog"
	}

	if err := cloneRepo(repo); err != nil {
		fmt.Printf("‚ùå Failed to clone repo: %v\n", err)
		os.Exit(1)
	}

	repoPath := filepath.Join(".", filepath.Base(repo))
	if err := updateModulesConcurrently(repoPath, versionConstraint); err != nil {
		fmt.Printf("‚ùå Failed to update modules: %v\n", err)
		os.Exit(1)
	}

	if dryRun {
		fmt.Println("üîç Dry run complete.")
		fmt.Printf("üîç Files that would be updated: %d\n", len(updatedFiles))
		for _, f := range updatedFiles {
			fmt.Println("üîç", f)
		}
		return
	}

	prURL, err := createPR(repo, branch)
	if err != nil {
		fmt.Printf("‚ùå Failed to create PR: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("‚úÖ Operation completed. Total files updated: %d\n", len(updatedFiles))
	for _, f := range updatedFiles {
		fmt.Println("‚úÖ", f)
	}
	fmt.Printf("üîó PR created: %s\n", prURL)
}


==========

# üê∏ Terraform Module Migrator (Frogmigrator)

A CLI tool to automate migration of Terraform modules from Git-based sources to a private Terraform registry (e.g., JFrog Artifactory), and update module version constraints.

---

## üöÄ Use Cases

* ‚úÖ **Migrate**: Convert `git::https://github.com/...` module sources to registry-based sources
* üîÅ **Update**: Modify `version = "~> x.y"` constraints in already-migrated JFrog modules

---

## üõ†Ô∏è CLI Usage

```bash
terraform-module-migrator [options] <repo-name>
```

### üî° Arguments

* `<repo-name>`: GitHub repository name (required)

### ‚öôÔ∏è Options

| Option                   | Description                                                        |
| ------------------------ | ------------------------------------------------------------------ |
| `--migrate-to-jfrog`     | Migrate Git-based module sources to registry                       |
| `--update-jfrog-version` | Update `version = "~> x.y"` constraint for existing JFrog modules  |
| `--version <x.y>`        | Required for `--update-jfrog-version`. Version constraint to apply |
| `--dry-run`              | Preview changes without modifying files                            |
| `--help`                 | Show usage and exit                                                |

---

## üì¶ Examples

### üîÑ Migrate Git modules to JFrog registry

```bash
terraform-module-migrator --migrate-to-jfrog my-infra-repo
```

**Transforms:**

```hcl
# Before
source = "git::https://github.com/platform-org/modules.git//gclb?ref=refs/tags/v1.2.2"

# After
source  = "registry.terraform.example.com/org/gclb/google"
version = "~> 1.0"
```

---

### üéØ Update version in already migrated JFrog modules

```bash
terraform-module-migrator --update-jfrog-version --version 2.0 my-infra-repo
```

**Updates:**

```hcl
# Before
version = "~> 1.0"

# After
version = "~> 2.0"
```

---

### üß™ Preview only (Dry Run)

```bash
terraform-module-migrator --update-jfrog-version --version 2.0 --dry-run my-infra-repo
```

---

## üîç How It Works

1. üß¨ **Clone**: Clones the specified GitHub repo using SSH
2. üìÇ **Scan**: Recursively finds all `.tf` files
3. üîÅ **Replace or Update**:

   * If `--migrate-to-jfrog`:

     * Replace Git source lines with registry source
     * Inject `version = "~> x.y"`
   * If `--update-jfrog-version`:

     * Locate existing `version =` lines and update
4. ‚úÖ **Commit**: Creates new branch and commits updated files
5. üöÄ **Push & PR**: Pushes branch and opens GitHub PR using Git CLI

---

## üí° Assumptions

* Registry format is: `registry.terraform.example.com/org/<module>/google`
* PR branch is automatically named:

  * `migrate-to-jfrog` or
  * `update-jfrog-version`
* Only `.tf` files are scanned

---

## üê∏ Nickname

This tool is also affectionately known as **Frogmigrator** üê∏üí®

---

## üìÑ License

MIT (or internal license)

