package ui

import (
	"chaoscli/actions"
	"chaoscli/cloudrun"
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type state int

const (
	selectProject state = iota
	selectService
	selectRevision
	selectChaos
	selectFault
	done
)

var (
	titleStyle    = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("205"))
	cursorStyle   = lipgloss.NewStyle().Foreground(lipgloss.Color("212"))
	selectedStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("229")).Background(lipgloss.Color("57")).Bold(true)
	helpStyle     = lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Italic(true)
)

type item struct {
	title, desc string
}

func (i item) Title() string       { return i.title }
func (i item) Description() string { return i.desc }
func (i item) FilterValue() string { return i.title }

type model struct {
	state        state
	projectList  list.Model
	serviceList  list.Model
	revisionList list.Model
	selectedProj string
	selectedSvc  string
	selectedRev  string
	chaosMenu    menuModel
	faultMenu    menuModel
}

func InitialModel() model {
	projects, err := cloudrun.LoadProjectsFromGCS()
	if err != nil {
		panic(err)
	}
	var items []list.Item
	for _, p := range projects {
		items = append(items, item{title: p, desc: "Google Cloud Project"})
	}
	l := list.New(items, list.NewDefaultDelegate(), 50, 10)
	l.Title = titleStyle.Render("Select a GCP Project")
	l.SetShowFilter(true)
	l.SetFilteringEnabled(true)
	l.Paginator.PerPage = 5
	return model{state: selectProject, projectList: l}
}

func (m model) Init() tea.Cmd {
	return nil
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch m.state {
	case selectProject:
		var cmd tea.Cmd
		m.projectList, cmd = m.projectList.Update(msg)
		if key, ok := msg.(tea.KeyMsg); ok {
			switch key.String() {
			case "enter":
				if i, ok := m.projectList.SelectedItem().(item); ok {
					m.selectedProj = i.title
					m.state = selectService

					services, err := cloudrun.ListCloudRunServices(m.selectedProj)
					if err != nil {
						panic(err)
					}
					var items []list.Item
					for _, s := range services {
						items = append(items, item{title: s, desc: "Cloud Run Service"})
					}
					m.serviceList = list.New(items, list.NewDefaultDelegate(), 50, 10)
					m.serviceList.Title = titleStyle.Render("Select Cloud Run Service")
					m.serviceList.SetShowFilter(true)
					m.serviceList.SetFilteringEnabled(true)
					m.serviceList.Paginator.PerPage = 5
				}
			case "b":
				return m, tea.Quit
			}
		}
		return m, cmd

	case selectService:
		var cmd tea.Cmd
		m.serviceList, cmd = m.serviceList.Update(msg)
		if key, ok := msg.(tea.KeyMsg); ok {
			switch key.String() {
			case "enter":
				if i, ok := m.serviceList.SelectedItem().(item); ok {
					m.selectedSvc = i.title
					m.state = selectRevision

					revisions, err := cloudrun.ListRevisionsWithTraffic(m.selectedProj, m.selectedSvc)
					if err != nil {
						panic(err)
					}
					var items []list.Item
					for _, r := range revisions {
						items = append(items, item{title: r, desc: "Revision with Traffic"})
					}
					m.revisionList = list.New(items, list.NewDefaultDelegate(), 50, 10)
					m.revisionList.Title = titleStyle.Render("Select Revision")
					m.revisionList.SetShowFilter(true)
					m.revisionList.SetFilteringEnabled(true)
					m.revisionList.Paginator.PerPage = 5
				}
			case "b":
				m.state = selectProject
			}
		}
		return m, cmd

	case selectRevision:
		var cmd tea.Cmd
		m.revisionList, cmd = m.revisionList.Update(msg)
		if key, ok := msg.(tea.KeyMsg); ok {
			switch key.String() {
			case "enter":
				if i, ok := m.revisionList.SelectedItem().(item); ok {
					m.selectedRev = i.title
					m.state = selectChaos
					m.chaosMenu = newMenu("Choose chaos action", []string{"Bring down service", "Inject fault"})
				}
			case "b":
				m.state = selectService
			}
		}
		return m, cmd

	case selectChaos:
		var cmd tea.Cmd
		m.chaosMenu, cmd = m.chaosMenu.Update(msg)
		if m.chaosMenu.Confirmed() {
			if m.chaosMenu.SelectedIndex() == 0 {
				actions.LogChaosAction(m.selectedProj, m.selectedSvc, m.selectedRev, "Bring down service")
				m.state = done
			} else {
				m.faultMenu = newMenu("Select Fault Type", []string{"Add Delay", "Return 5xx", "Return 4xx"})
				m.state = selectFault
			}
		}
		return m, cmd

	case selectFault:
		var cmd tea.Cmd
		m.faultMenu, cmd = m.faultMenu.Update(msg)
		if m.faultMenu.Confirmed() {
			actions.LogChaosAction(m.selectedProj, m.selectedSvc, m.selectedRev, m.faultMenu.Selected())
			m.state = done
		}
		return m, cmd

	case done:
		return m, tea.Quit
	}
	return m, nil
}

func (m model) View() string {
	switch m.state {
	case selectProject:
		return m.projectList.View() + "\n" + helpStyle.Render("(press 'b' to quit)")
	case selectService:
		return m.serviceList.View() + "\n" + helpStyle.Render("(press 'b' to go back)")
	case selectRevision:
		return m.revisionList.View() + "\n" + helpStyle.Render("(press 'b' to go back)")
	case selectChaos:
		return m.chaosMenu.View()
	case selectFault:
		return m.faultMenu.View()
	case done:
		return "\n✅ Chaos action logged. Exiting.\n"
	}
	return "Loading..."
}

// Menu selector

type menuModel struct {
	title   string
	options []string
	cursor  int
	choice  int
	confirm bool
}

func newMenu(title string, options []string) menuModel {
	return menuModel{title: title, options: options, cursor: 0, confirm: false}
}

func (m menuModel) Update(msg tea.Msg) (menuModel, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "up", "k":
			if m.cursor > 0 {
				m.cursor--
			}
		case "down", "j":
			if m.cursor < len(m.options)-1 {
				m.cursor++
			}
		case "enter":
			m.choice = m.cursor
			m.confirm = true
		case "b":
			m.confirm = false
		}
	}
	return m, nil
}

func (m menuModel) View() string {
	var b strings.Builder
	b.WriteString(titleStyle.Render(m.title) + "\n\n")
	for i, opt := range m.options {
		cursor := "  "
		if m.cursor == i {
			cursor = cursorStyle.Render("➜ ")
		}
		if m.cursor == i {
			b.WriteString(fmt.Sprintf("%s%s\n", cursor, selectedStyle.Render(opt)))
		} else {
			b.WriteString(fmt.Sprintf("%s%s\n", cursor, opt))
		}
	}
	return b.String() + helpStyle.Render("\n(press 'b' to go back)")
}

func (m menuModel) Confirmed() bool    { return m.confirm }
func (m menuModel) Selected() string   { return m.options[m.choice] }
func (m menuModel) SelectedIndex() int { return m.choice }
