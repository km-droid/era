// main.go
package main

import (
    "bytes"
    "cloud.google.com/go/storage"
    "context"
    "encoding/csv"
    "encoding/json"
    "flag"
    "fmt"
    "io"
    "io/ioutil"
    "net/http"
    "os"
    "sort"
    "strings"
    "sync"

    "golang.org/x/oauth2"
    "golang.org/x/oauth2/google"
    "google.golang.org/api/iterator"
)

const (
    apiBase     = "https://gdchardwaremanagement.googleapis.com/v1alpha"
    projectID   = "your-project-id"
    region      = "us-east1"
    gcsBucket   = "your-gcs-bucket"
    ordersCSV   = "orders.csv"
    statePrefix = "state/"
)

var (
    zoneNetworkConfig = map[string]interface{}{
        "defaultGateway": true,
        "network":        "default",
    }

    hardwareDefaults = map[string]interface{}{
        "powerRequirements": "120V",
        "weight":            "20kg",
        "dimensions": map[string]interface{}{
            "width":  480,
            "height": 88,
            "depth":  500,
        },
    }
)

type OrderInfo struct {
    OrderID          string
    SiteID           string
    SiteDisplay      string
    SiteDesc         string
    SiteAddress      string
    SiteRep          string
    SiteEmail        string
    ZoneID           string
    ZoneDisplay      string
    HardwareID       string
    SKU              string
    OrderDisplay     string
    CompanyName      string
    CompanyEmail     string
    CompanyPhone     string
    ContactFirst     string
    ContactLast      string
    ContactEmail     string
    ContactPhone     string
    DeliveryDate     string
    RackLocation     string
    RackType         string
}

type StepState struct {
    SiteCreated     bool `json:"site_created"`
    ZoneCreated     bool `json:"zone_created"`
    HardwareCreated bool `json:"hardware_created"`
    OrderCreated    bool `json:"order_created"`
}

func main() {
    checkAll := flag.Bool("check-status", false, "Check status of all orders")
    checkOne := flag.String("check-order-status", "", "Check status of a specific order")
    flag.Parse()

    ctx := context.Background()
    creds, err := google.FindDefaultCredentials(ctx, "https://www.googleapis.com/auth/cloud-platform")
    if err != nil {
        panic(err)
    }
    client := oauth2.NewClient(ctx, creds.TokenSource)
    gcsClient, err := storage.NewClient(ctx)
    if err != nil {
        panic(err)
    }

    switch {
    case *checkAll:
        checkAllStatuses(ctx, client, gcsClient)
        return
    case *checkOne != "":
        checkOrderStatus(ctx, client, *checkOne)
        return
    }

    orders, err := readOrdersCSVFromGCS(ctx, gcsClient)
    if err != nil {
        panic(err)
    }

    orderChan := make(chan OrderInfo)
    var wg sync.WaitGroup
    var mu sync.Mutex
    summary := make(map[string]string)

    for i := 0; i < 5; i++ {
        go func() {
            for order := range orderChan {
                success := processOrder(order, client, gcsClient, ctx)
                mu.Lock()
                summary[order.OrderID] = map[bool]string{true: "âœ… Success", false: "âŒ Failed"}[success]
                mu.Unlock()
                wg.Done()
            }
        }()
    }

    for _, o := range orders {
        wg.Add(1)
        orderChan <- o
    }
    close(orderChan)
    wg.Wait()

    fmt.Println("\nðŸ“¦ Order Processing Summary")
    keys := make([]string, 0, len(summary))
    for k := range summary {
        keys = append(keys, k)
    }
    sort.Strings(keys)
    for _, id := range keys {
        fmt.Printf("Order %s: %s\n", id, summary[id])
    }
}

func checkAllStatuses(ctx context.Context, client *http.Client, gcsClient *storage.Client) {
    fmt.Println("ðŸ”Ž Checking all order statuses...")
    it := gcsClient.Bucket(gcsBucket).Objects(ctx, &storage.Query{Prefix: statePrefix})
    for {
        objAttrs, err := it.Next()
        if err == iterator.Done {
            break
        }
        if err != nil {
            fmt.Printf("Error listing GCS objects: %v\n", err)
            return
        }
        if strings.HasSuffix(objAttrs.Name, "_state.json") {
            orderID := strings.TrimPrefix(strings.TrimSuffix(objAttrs.Name, "_state.json"), statePrefix)
            checkOrderStatus(ctx, client, orderID)
        }
    }
}

func checkOrderStatus(ctx context.Context, client *http.Client, orderID string) {
    url := fmt.Sprintf("%s/projects/%s/locations/%s/orders/%s", apiBase, projectID, region, orderID)
    req, _ := http.NewRequest("GET", url, nil)
    req.Header.Set("Content-Type", "application/json")
    resp, err := client.Do(req)
    if err != nil {
        fmt.Printf("Order %s: âŒ Error - %v\n", orderID, err)
        return
    }
    defer resp.Body.Close()
    body, _ := io.ReadAll(resp.Body)
    if resp.StatusCode >= 200 && resp.StatusCode < 300 {
        var result map[string]interface{}
        json.Unmarshal(body, &result)
        status := result["state"]
        fmt.Printf("Order %s: âœ… Status - %v\n", orderID, status)
    } else {
        fmt.Printf("Order %s: âŒ API error - %s\n", orderID, string(body))
    }
}
