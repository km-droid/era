{
        "displayName": order.HardwareID,
        "sku":         order.Hardware.SKU,
        "zone":        fmt.Sprintf("projects/%s/locations/us-east1/zones/%s", projectID, order.ZoneID),
        "installationInfo": map[string]interface{}{
            "rack": map[string]interface{}{
                "location": order.Hardware.RackLocation,
                "rackType": order.Hardware.RackType,
            },
            "dimensions": map[string]interface{}{
                "height": 88,
                "width":  480,
                "depth":  500,
            },
            "weight":            "20kg",
            "powerRequirements": "120V",
            "coolingRequirements": "Air cooled",
            "mountingDetails": map[string]interface{}{
                "mountType": "rack",
                "mountPoints": []string{"front", "rear"},
            },
            "networkPorts": []map[string]interface{}{
                {
                    "portType":   "ethernet",
                    "portCount":  2,
                    "speedGbps":  10,
                },
            },
        },
        "group": map[string]interface{}{
            "displayName": "Primary Rack Group",
            "purpose":      "Edge compute node",
            "annotations": map[string]string{
                "location": "ny",
                "rack":     "rack-a1",
            },
        },
        "config": map[string]interface{}{
            "hardwareModel": "GDC medium",
            "hardwareType":  "connected-server",
            "capacity": map[string]interface{}{
                "cpuCores":    8,
                "memoryGb":    32,
                "storageGb":   512,
                "accelerators": []map[string]interface{}{
                    {
                        "type":   "tpu",
                        "count":  1,
                    },
                },
            },
            "firmwareVersion": "v1.2.3",
            "biosSettings": map[string]interface{}{
                "secureBoot": true,
                "virtualization": true,
            },
        },
    }
======================================
@@ -1 +1,909 @@
package main

import (
	"bytes"
	cloudcreds "cloud.google.com/go/iam/credentials/apiv1"
	"cloud.google.com/go/datastore"
	"context"
	"encoding/json"
	"fmt"
	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"time"

	credentialspb "google.golang.org/genproto/googleapis/iam/credentials/v1"
)

type Order struct {
	OrderID          string    `datastore:"orderId"`
	SiteID           string    `datastore:"siteId"`
	ZoneID           string    `datastore:"zoneId"`
	HardwareID       string    `datastore:"hardwareId"`
	Status           string    `datastore:"status"`
	GDCStatus        string    `datastore:"gdcStatus"`
	ZoneCreated      bool      `datastore:"zoneCreated"`
	ClusterTriggered bool      `datastore:"clusterTriggered"`
	SiteCreated      bool      `datastore:"siteCreated"`
	ZoneCreatedStep  bool      `datastore:"zoneCreatedStep"`
	HardwareCreated  bool      `datastore:"hardwareCreated"`
	OrderCreated     bool      `datastore:"orderCreated"`
	LastChecked      time.Time `datastore:"lastChecked"`
	Company          struct {
		CompanyName  string `datastore:"companyName"`
		Email        string `datastore:"email"`
		Phone        string `datastore:"phone"`
		DeliveryDate string `datastore:"deliveryDate"`
	} `datastore:"company"`
	Contact struct {
		FirstName string `datastore:"firstName"`
		LastName  string `datastore:"lastName"`
		Email     string `datastore:"email"`
		Phone     string `datastore:"phone"`
	} `datastore:"contact"`
	Site struct {
		DisplayName string `datastore:"displayName"`
		Description string `datastore:"description"`
		Address     string `datastore:"address"`
		Rep         string `datastore:"rep"`
		Email       string `datastore:"email"`
	} `datastore:"site"`
	Zone struct {
		DisplayName string `datastore:"displayName"`
	} `datastore:"zone"`
	Hardware struct {
		SKU          string `datastore:"sku"`
		RackLocation string `datastore:"rackLocation"`
		RackType     string `datastore:"rackType"`
	} `datastore:"hardware"`
}

var (
	projectID = os.Getenv("GCP_PROJECT")
	dsClient  *datastore.Client
  logger    = logrus.New()
)

func init() {
    logger.SetFormatter(&logrus.JSONFormatter{})
    logger.SetOutput(os.Stdout)
    logger.SetLevel(logrus.InfoLevel)
}

func main() {
	ctx := context.Background()
	var err error
	dsClient, err = datastore.NewClient(ctx, projectID)
	if err != nil {
		log.Fatalf("Failed to create datastore client: %v", err)
	}

	http.HandleFunc("/pubsub/create-orders", pubsubHandler(handleCreateOrders))
	http.HandleFunc("/pubsub/check-status", pubsubHandler(handleCheckStatus))
	http.HandleFunc("/pubsub/check-zone", pubsubHandler(handleCheckZone))

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	log.Printf("Listening on port %s", port)
	log.Fatal(http.ListenAndServe(":"+port, nil))
}

type PubSubMessage struct {
	Message struct {
		Data       []byte            `json:"data"`
		Attributes map[string]string `json:"attributes"`
	} `json:"message"`
	Subscription string `json:"subscription"`
}

func pubsubHandler(fn func(context.Context)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var m PubSubMessage
		if err := json.NewDecoder(r.Body).Decode(&m); err != nil {
			log.Printf("Error decoding pubsub message: %v", err)
			http.Error(w, "Bad Request", http.StatusBadRequest)
			return
		}
		go fn(r.Context())
		fmt.Fprint(w, "OK")
	}
}

func handleCreateOrders(ctx context.Context) {
	q := datastore.NewQuery("Order").Filter("status =", "new")
	var orders []Order
	keys, err := dsClient.GetAll(ctx, q, &orders)
	if err != nil {
		 logger.WithError(err).Error("Datastore query failed")
		return
	}
	for i, order := range orders {
		key := keys[i]
    entry := logger.WithField("orderId", order.OrderID)
 if !order.SiteCreated {
            if createSite(order, entry) {
                order.SiteCreated = true
            } else {
                steps = append(steps, "site")
            }
        }
        if order.SiteCreated && !order.ZoneCreatedStep {
            if createZone(order, entry) {
                order.ZoneCreatedStep = true
            } else {
                steps = append(steps, "zone")
            }
        }
        if order.ZoneCreatedStep && !order.HardwareCreated {
            if createHardware(order, entry) {
                order.HardwareCreated = true
            } else {
                steps = append(steps, "hardware")
            }
        }
        if order.HardwareCreated && !order.OrderCreated {
            if createGDCOrder(order, entry) {
                order.OrderCreated = true
            } else {
                steps = append(steps, "gdc-order")
            }
        }

        if order.SiteCreated && order.ZoneCreatedStep && order.HardwareCreated && order.OrderCreated {
            order.Status = "submitted"
            entry.Info("All creation steps completed, order submitted")
        } else {
            entry.WithField("pendingSteps", steps).Warn("Order incomplete, retrying remaining steps later")
        }
	}
}

func createSite(order Order) bool {
	url := fmt.Sprintf("https://gdchardwaremanagement.googleapis.com/v1alpha/projects/%s/locations/us-east1/sites?siteId=%s", projectID, order.SiteID)
	body := map[string]interface{}{
		"displayName": order.Site.DisplayName,
		"description": order.Site.Description,
		"contact": map[string]string{
			"givenName": order.Site.Rep,
			"email":     order.Site.Email,
		},
		"address": map[string]interface{}{
			"regionCode":         "US",
			"addressLines":       []string{order.Site.Address},
			"locality":           "NY",
			"administrativeArea": "NY",
			"postalCode":         "10001",
		},
	}
  success := doPost(url, body)
	if success {
        log.Info("Site created successfully")
    } else {
        log.Warn("Site creation failed")
    }
    return success
}

func createZone(order Order) bool {
	url := fmt.Sprintf("https://gdchardwaremanagement.googleapis.com/v1alpha/projects/%s/locations/us-east1/zones?zoneId=%s", projectID, order.ZoneID)
	body := map[string]interface{}{
		"displayName": order.Zone.DisplayName,
		"site":        fmt.Sprintf("projects/%s/locations/us-east1/sites/%s", projectID, order.SiteID),
		"networkConfig": map[string]interface{}{
			"defaultGateway": true,
			"network":        "default",
		},
	}
	success := doPost(url, body)
    if success {
        log.Info("Zone created successfully")
    } else {
        log.Warn("Zone creation failed")
    }
    return success
}

func createHardware(order Order) bool {
	url := fmt.Sprintf("https://gdchardwaremanagement.googleapis.com/v1alpha/projects/%s/locations/us-east1/hardware?hardwareId=%s", projectID, order.HardwareID)
	body := map[string]interface{}{
		"displayName": order.HardwareID,
		"sku":         order.Hardware.SKU,
		"zone":        fmt.Sprintf("projects/%s/locations/us-east1/zones/%s", projectID, order.ZoneID),
		"installationInfo": map[string]interface{}{
			"rack": map[string]interface{}{
				"location": order.Hardware.RackLocation,
				"rackType": order.Hardware.RackType,
			},
			"dimensions": map[string]interface{}{
				"width":  480,
				"height": 88,
				"depth":  500,
			},
			"weight":            "20kg",
			"powerRequirements": "120V",
		},
	}
	success := doPost(url, body)
    if success {
        log.Info("Hardware created successfully")
    } else {
        log.Warn("Hardware creation failed")
    }
    return success
}

func createGDCOrder(order Order) bool {
	url := fmt.Sprintf("https://gdchardwaremanagement.googleapis.com/v1alpha/projects/%s/locations/us-east1/orders?orderId=%s", projectID, order.OrderID)
	body := map[string]interface{}{
		"displayName": order.OrderID,
		"site":        fmt.Sprintf("projects/%s/locations/us-east1/sites/%s", projectID, order.SiteID),
		"zone":        fmt.Sprintf("projects/%s/locations/us-east1/zones/%s", projectID, order.ZoneID),
		"contact": map[string]string{
			"givenName":  order.Contact.FirstName,
			"familyName": order.Contact.LastName,
			"email":      order.Contact.Email,
			"phone":      order.Contact.Phone,
		},
	}
	success := doPost(url, body)
    if success {
        log.Info("GDC Order created successfully")
    } else {
        log.Warn("GDC Order creation failed")
    }
    return success
}

func handleCheckStatus(ctx context.Context) {
    q := datastore.NewQuery("Order").Filter("status =", "submitted")
    var orders []Order
    keys, err := dsClient.GetAll(ctx, q, &orders)
    if err != nil {
        logger.WithError(err).Error("Failed to query submitted orders")
        return
    }
    for i, order := range orders {
        entry := logger.WithField("orderId", order.OrderID)
        status := getOrderStatus(order.OrderID)
        if status == "COMPLETED" {
            order.Status = "completed"
            order.LastChecked = time.Now()
            dsClient.Put(ctx, keys[i], &order)
            entry.Info("Order marked as completed")
        } else {
            entry.WithField("gdcStatus", status).Info("Order still processing")
        }
    }
}

func getOrderStatus(orderID string) string {
	url := fmt.Sprintf("https://gdchardwaremanagement.googleapis.com/v1alpha/projects/%s/locations/us-east1/orders/%s", projectID, orderID)
	data, err := doGet(url)
	if err != nil {
		return ""
	}
	var out map[string]interface{}
	json.Unmarshal(data, &out)
	if val, ok := out["state"].(string); ok {
		return val
	}
	return ""
}

func handleCheckZone(ctx context.Context) {
    q := datastore.NewQuery("Order").Filter("status =", "completed").Filter("zoneCreated =", false)
    var orders []Order
    keys, err := dsClient.GetAll(ctx, q, &orders)
    if err != nil {
        logger.WithError(err).Error("Failed to query completed orders for zone check")
        return
    }
    for i, order := range orders {
        entry := logger.WithField("orderId", order.OrderID)
        if checkZoneExists(order.ZoneID) {
            order.ZoneCreated = true
            triggerClusterProvisioning(ctx, order.ZoneID, entry)
            order.ClusterTriggered = true
            order.LastChecked = time.Now()
            dsClient.Put(ctx, keys[i], &order)
            entry.Info("Zone ready and cluster provisioning triggered")
        } else {
            entry.Warn("Zone not ready yet")
        }
    }
}

func checkZoneExists(zoneID string) bool {
	url := fmt.Sprintf("https://gdchardwaremanagement.googleapis.com/v1alpha/projects/%s/locations/us-east1/zones/%s", projectID, zoneID)
	_, err := doGet(url)
	return err == nil
}

func triggerClusterProvisioning(ctx context.Context, zoneID string) {
	sa := fmt.Sprintf("cluster-provisioner@%s.iam.gserviceaccount.com", projectID)
	impClient, err := cloudcreds.NewIamCredentialsClient(ctx)
	if err != nil {
		log.Printf("impersonation error: %v", err)
		return
	}
	defer impClient.Close()

	tokenResp, err := impClient.GenerateAccessToken(ctx, &credentialspb.GenerateAccessTokenRequest{
		Name:  "projects/-/serviceAccounts/" + sa,
		Scope: []string{"https://www.googleapis.com/auth/cloud-platform"},
	})
	if err != nil {
		log.Printf("token gen failed: %v", err)
		return
	}

	client := oauth2.NewClient(ctx, oauth2.StaticTokenSource(&oauth2.Token{
		AccessToken: tokenResp.AccessToken,
	}))
	req, _ := http.NewRequest("POST", "https://provisioner.example.com/api/trigger", nil)
	resp, err := client.Do(req)
	if err != nil {
		log.Printf("cluster provisioning failed: %v", err)
		return
	}
	defer resp.Body.Close()
	log.Printf("cluster provision triggered: %d", resp.StatusCode)
}

func doPost(url string, body map[string]interface{}) bool {
	ctx := context.Background()
	creds, _ := google.FindDefaultCredentials(ctx, "https://www.googleapis.com/auth/cloud-platform")
	client := oauth2.NewClient(ctx, creds.TokenSource)
	data, _ := json.Marshal(body)
	req, _ := http.NewRequest("POST", url, bytes.NewBuffer(data))
	req.Header.Set("Content-Type", "application/json")
	resp, err := client.Do(req)
	if err != nil {
		log.Printf("POST error: %v", err)
		return false
	}
	defer resp.Body.Close()
	return resp.StatusCode >= 200 && resp.StatusCode < 300
}

func doGet(url string) ([]byte, error) {
	ctx := context.Background()
	creds, _ := google.FindDefaultCredentials(ctx, "https://www.googleapis.com/auth/cloud-platform")
	client := oauth2.NewClient(ctx, creds.TokenSource)
	req, _ := http.NewRequest("GET", url, nil)
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	return ioutil.ReadAll(resp.Body)
}
============================================

// csv_importer_cli.go - CLI tool to import orders into Datastore
package main

import (
	"cloud.google.com/go/datastore"
	"context"
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"time"
)

type Order struct {
	OrderID          string
	SiteID           string
	ZoneID           string
	HardwareID       string
	Status           string
	LastChecked      time.Time
	SiteCreated      bool
	ZoneCreatedStep  bool
	HardwareCreated  bool
	OrderCreated     bool
	ZoneCreated      bool
	ClusterTriggered bool
	Company          struct {
		CompanyName  string
		Email        string
		Phone        string
		DeliveryDate string
	}
	Contact struct {
		FirstName string
		LastName  string
		Email     string
		Phone     string
	}
	Site struct {
		DisplayName string
		Description string
		Address     string
		Rep         string
		Email       string
	}
	Zone struct {
		DisplayName string
	}
	Hardware struct {
		SKU          string
		RackLocation string
		RackType     string
	}
}

func main() {
	projectID := os.Getenv("GCP_PROJECT")
	if projectID == "" {
		log.Fatal("GCP_PROJECT environment variable is not set")
	}

	if len(os.Args) < 2 {
		log.Fatal("Usage: go run main.go <orders.csv>")
	}
	csvPath := os.Args[1]

	ctx := context.Background()
	dsClient, err := datastore.NewClient(ctx, projectID)
	if err != nil {
		log.Fatalf("Failed to create datastore client: %v", err)
	}
	defer dsClient.Close()

	file, err := os.Open(csvPath)
	if err != nil {
		log.Fatalf("Failed to open file: %v", err)
	}
	defer file.Close()

	r := csv.NewReader(file)
	records, err := r.ReadAll()
	if err != nil {
		log.Fatalf("Failed to read CSV: %v", err)
	}
	if len(records) < 2 {
		log.Fatal("CSV must include headers and at least one data row")
	}

	headers := records[0]
	rows := records[1:]

	for _, row := range rows {
		order := Order{
			OrderID:          row[0],
			SiteID:           row[1],
			ZoneID:           row[2],
			HardwareID:       row[3],
			Status:           "new",
			LastChecked:      time.Now(),
			SiteCreated:      false,
			ZoneCreatedStep:  false,
			HardwareCreated:  false,
			OrderCreated:     false,
			ZoneCreated:      false,
			ClusterTriggered: false,
		}
		order.Company.CompanyName = row[4]
		order.Company.Email = row[5]
		order.Company.Phone = row[6]
		order.Company.DeliveryDate = row[7]
		order.Contact.FirstName = row[8]
		order.Contact.LastName = row[9]
		order.Contact.Email = row[10]
		order.Contact.Phone = row[11]
		order.Site.DisplayName = row[12]
		order.Site.Description = row[13]
		order.Site.Address = row[14]
		order.Site.Rep = row[15]
		order.Site.Email = row[16]
		order.Zone.DisplayName = row[17]
		order.Hardware.SKU = row[18]
		order.Hardware.RackLocation = row[19]
		order.Hardware.RackType = row[20]

		key := datastore.NameKey("Order", order.OrderID, nil)
		if _, err := dsClient.Put(ctx, key, &order); err != nil {
			log.Printf("Failed to insert order %s: %v", order.OrderID, err)
		} else {
			fmt.Printf("✅ Imported order: %s\n", order.OrderID)
		}
	}
}
================================================
package main

import (
	"cloud.google.com/go/datastore"
	"cloud.google.com/go/functions/metadata"
	"cloud.google.com/go/storage"
	"context"
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"strings"
	"time"
)

type Order struct {
	OrderID          string
	SiteID           string
	ZoneID           string
	HardwareID       string
	Status           string
	LastChecked      time.Time
	SiteCreated      bool
	ZoneCreatedStep  bool
	HardwareCreated  bool
	OrderCreated     bool
	ZoneCreated      bool
	ClusterTriggered bool
	Company          struct {
		CompanyName  string
		Email        string
		Phone        string
		DeliveryDate string
	}
	Contact struct {
		FirstName string
		LastName  string
		Email     string
		Phone     string
	}
	Site struct {
		DisplayName string
		Description string
		Address     string
		Rep         string
		Email       string
	}
	Zone struct {
		DisplayName string
	}
	Hardware struct {
		SKU          string
		RackLocation string
		RackType     string
	}
}

// GCSEvent is the payload of a GCS event.
type GCSEvent struct {
	Bucket string `json:"bucket"`
	Name   string `json:"name"`
}

func ImportOrdersFromGCS(ctx context.Context, e GCSEvent) error {
	projectID := os.Getenv("GCP_PROJECT")
	if projectID == "" {
		return fmt.Errorf("GCP_PROJECT environment variable not set")
	}
	dsClient, err := datastore.NewClient(ctx, projectID)
	if err != nil {
		return fmt.Errorf("failed to create datastore client: %w", err)
	}
	defer dsClient.Close()

	stClient, err := storage.NewClient(ctx)
	if err != nil {
		return fmt.Errorf("failed to create storage client: %w", err)
	}
	defer stClient.Close()

	rc, err := stClient.Bucket(e.Bucket).Object(e.Name).NewReader(ctx)
	if err != nil {
		return fmt.Errorf("failed to read object gs://%s/%s: %w", e.Bucket, e.Name, err)
	}
	defer rc.Close()

	r := csv.NewReader(rc)
	records, err := r.ReadAll()
	if err != nil {
		return fmt.Errorf("failed to parse CSV: %w", err)
	}
	if len(records) < 2 {
		return fmt.Errorf("CSV has no data rows")
	}

	rows := records[1:]
	for _, row := range rows {
		order := Order{
			OrderID:          row[0],
			SiteID:           row[1],
			ZoneID:           row[2],
			HardwareID:       row[3],
			Status:           "new",
			LastChecked:      time.Now(),
			SiteCreated:      false,
			ZoneCreatedStep:  false,
			HardwareCreated:  false,
			OrderCreated:     false,
			ZoneCreated:      false,
			ClusterTriggered: false,
		}
		order.Company.CompanyName = row[4]
		order.Company.Email = row[5]
		order.Company.Phone = row[6]
		order.Company.DeliveryDate = row[7]
		order.Contact.FirstName = row[8]
		order.Contact.LastName = row[9]
		order.Contact.Email = row[10]
		order.Contact.Phone = row[11]
		order.Site.DisplayName = row[12]
		order.Site.Description = row[13]
		order.Site.Address = row[14]
		order.Site.Rep = row[15]
		order.Site.Email = row[16]
		order.Zone.DisplayName = row[17]
		order.Hardware.SKU = row[18]
		order.Hardware.RackLocation = row[19]
		order.Hardware.RackType = row[20]

		key := datastore.NameKey("Order", order.OrderID, nil)
		if _, err := dsClient.Put(ctx, key, &order); err != nil {
			log.Printf("❌ Failed to insert order %s: %v", order.OrderID, err)
		} else {
			log.Printf("✅ Imported order: %s", order.OrderID)
		}
	}

	log.Printf("✅ Completed importing orders from gs://%s/%s", e.Bucket, e.Name)
	return nil
}
====================================

# cloud_scheduler.yaml

resources:
- name: scheduler-create-orders
  type: gcp-types/cloudscheduler-v1:projects.locations.jobs
  properties:
    schedule: "*/10 * * * *"
    timeZone: "Etc/UTC"
    name: "projects/$PROJECT_ID/locations/$REGION/jobs/scheduler-create-orders"
    httpTarget:
      uri: "https://pubsub.googleapis.com/v1/projects/$PROJECT_ID/topics/create-orders:publish"
      httpMethod: POST
      oidcToken:
        serviceAccountEmail: $SERVICE_ACCOUNT
    retryConfig:
      maxRetryDuration: "3600s"

- name: scheduler-check-status
  type: gcp-types/cloudscheduler-v1:projects.locations.jobs
  properties:
    schedule: "*/15 * * * *"
    timeZone: "Etc/UTC"
    name: "projects/$PROJECT_ID/locations/$REGION/jobs/scheduler-check-status"
    httpTarget:
      uri: "https://pubsub.googleapis.com/v1/projects/$PROJECT_ID/topics/check-status:publish"
      httpMethod: POST
      oidcToken:
        serviceAccountEmail: $SERVICE_ACCOUNT

- name: scheduler-check-zone
  type: gcp-types/cloudscheduler-v1:projects.locations.jobs
  properties:
    schedule: "*/20 * * * *"
    timeZone: "Etc/UTC"
    name: "projects/$PROJECT_ID/locations/$REGION/jobs/scheduler-check-zone"
    httpTarget:
      uri: "https://pubsub.googleapis.com/v1/projects/$PROJECT_ID/topics/check-zone:publish"
      httpMethod: POST
      oidcToken:
        serviceAccountEmail: $SERVICE_ACCOUNT

================================================

# workflows_publish_to_pubsub.yaml

main:
  params: [topic, attributes]
  steps:
    - init:
        assign:
          - project: ${sys.get_env("GOOGLE_CLOUD_PROJECT")}
    - publish:
        call: http.post
        args:
          url: ${"https://pubsub.googleapis.com/v1/projects/" + project + "/topics/" + topic + ":publish"}
          auth:
            type: OAuth2
          body:
            messages:
              - attributes: ${attributes}

==============================

# workflows_publish_to_pubsub.yaml

main:
  params: [topic, attributes]
  steps:
    - init:
        assign:
          - project: ${sys.get_env("GOOGLE_CLOUD_PROJECT")}
    - publish:
        call: http.post
        args:
          url: ${"https://pubsub.googleapis.com/v1/projects/" + project + "/topics/" + topic + ":publish"}
          auth:
            type: OAuth2
          body:
            messages:
              - attributes: ${attributes}

=====================================

IAM Roles Required
1. Cloud Scheduler
Service Account (Scheduler SA)
Used in the scheduler job to invoke Pub/Sub or Workflows.

Required Roles:

roles/pubsub.publisher → to publish to Pub/Sub topics

(Optional) roles/workflows.invoker → if you trigger Workflows directly

2. Cloud Workflows
Service Account used by the workflow runtime

Required Roles:

roles/pubsub.publisher → to publish to Pub/Sub (via HTTP)

roles/iam.serviceAccountTokenCreator → if impersonating another SA

(Optional) roles/datastore.user → if calling a Cloud Function/Run that accesses Datastore

3. Pub/Sub Topics
The following identities need roles/pubsub.publisher or roles/pubsub.subscriber on topics:


Identity	Role(s)	Access
Scheduler SA	roles/pubsub.publisher	Publishes trigger messages
Workflow SA	roles/pubsub.publisher	Publishes programmatic triggers
Cloud Function SA	roles/pubsub.subscriber	Receives messages (if not using HTTP)
4. Go Program (Cloud Run or Cloud Function)
Service Account used to deploy and run the Go service

Required Roles:

roles/datastore.user → read/write to Firestore in Datastore mode

roles/storage.objectViewer → read GCS objects (CSV)

roles/iam.serviceAccountTokenCreator → (optional) if impersonating other SAs

roles/logging.logWriter → emit logs to Cloud Logging

🔐 Example IAM Policy Binding (gcloud)
bash
Copy
Edit
# Allow Cloud Scheduler SA to publish to Pub/Sub
gcloud projects add-iam-policy-binding $PROJECT_ID \
  --member="serviceAccount:scheduler-sa@$PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/pubsub.publisher"

# Allow Go service SA to access Firestore and GCS
gcloud projects add-iam-policy-binding $PROJECT_ID \
  --member="serviceAccount:go-service@$PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/datastore.user"

gcloud projects add-iam-policy-binding $PROJECT_ID \
  --member="serviceAccount:go-service@$PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/storage.objectViewer"
Would you like a script to assign all these roles in one shot?






You said:
yes give me in terraform format


ChatGPT said:
Here is the complete Terraform configuration to assign IAM roles for:

Cloud Scheduler

Cloud Workflows

Cloud Functions / Cloud Run (Go service)

Pub/Sub access

✅ iam_roles.tf
hcl
Copy
Edit
variable "project_id" {
  type        = string
  description = "Your GCP project ID"
}

variable "region" {
  type        = string
  default     = "us-central1"
}

variable "scheduler_sa" {
  type        = string
  description = "Email of the Cloud Scheduler service account"
}

variable "workflow_sa" {
  type        = string
  description = "Email of the Workflow service account"
}

variable "go_service_sa" {
  type        = string
  description = "Email of the Go Cloud Function or Cloud Run service account"
}

# Pub/Sub roles
resource "google_project_iam_member" "scheduler_pubsub" {
  project = var.project_id
  role    = "roles/pubsub.publisher"
  member  = "serviceAccount:${var.scheduler_sa}"
}

resource "google_project_iam_member" "workflow_pubsub" {
  project = var.project_id
  role    = "roles/pubsub.publisher"
  member  = "serviceAccount:${var.workflow_sa}"
}

resource "google_project_iam_member" "workflow_token_creator" {
  project = var.project_id
  role    = "roles/iam.serviceAccountTokenCreator"
  member  = "serviceAccount:${var.workflow_sa}"
}

# Go service roles (Datastore, GCS, Logging)
resource "google_project_iam_member" "go_datastore" {
  project = var.project_id
  role    = "roles/datastore.user"
  member  = "serviceAccount:${var.go_service_sa}"
}

resource "google_project_iam_member" "go_storage_viewer" {
  project = var.project_id
  role    = "roles/storage.objectViewer"
  member  = "serviceAccount:${var.go_service_sa}"
}

resource "google_project_iam_member" "go_log_writer" {
  project = var.project_id
  role    = "roles/logging.logWriter"
  member  = "serviceAccount:${var.go_service_sa}"
}

resource "google_project_iam_member" "go_impersonation" {
  project = var.project_id
  role    = "roles/iam.serviceAccountTokenCreator"
  member  = "serviceAccount:${var.go_service_sa}"
}
🛠️ How to Use
Replace terraform.tfvars or pass -var values for:

hcl
Copy
Edit
project_id     = "your-gcp-project-id"
scheduler_sa   = "scheduler-sa@your-gcp-project-id.iam.gserviceaccount.com"
workflow_sa    = "workflow-runner@your-gcp-project-id.iam.gserviceaccount.com"
go_service_sa  = "cloudrun-or-cf-sa@your-gcp-project-id.iam.gserviceaccount.com"
