
package main

import (
    "bytes"
    "cloud.google.com/go/storage"
    "context"
    "encoding/csv"
    "encoding/json"
    "flag"
    "fmt"
    "io"
    "io/ioutil"
    "net/http"
    "os"
    "sort"
    "strings"
    "sync"

    "golang.org/x/oauth2"
    "golang.org/x/oauth2/google"
    "google.golang.org/api/iterator"
)

const (
    apiBase     = "https://gdchardwaremanagement.googleapis.com/v1alpha"
    projectID   = "your-project-id"
    region      = "us-east1"
    gcsBucket   = "your-gcs-bucket"
    ordersCSV   = "orders.csv"
    statePrefix = "state/"
)

var (
    zoneNetworkConfig = map[string]interface{}{
        "defaultGateway": true,
        "network":        "default",
    }

    hardwareDefaults = map[string]interface{}{
        "powerRequirements": "120V",
        "weight":            "20kg",
        "dimensions": map[string]interface{}{
            "width":  480,
            "height": 88,
            "depth":  500,
        },
    }
)

type OrderInfo struct {
    OrderID          string
    SiteID           string
    SiteDisplay      string
    SiteDesc         string
    SiteAddress      string
    SiteRep          string
    SiteEmail        string
    ZoneID           string
    ZoneDisplay      string
    HardwareID       string
    SKU              string
    OrderDisplay     string
    CompanyName      string
    CompanyEmail     string
    CompanyPhone     string
    ContactFirst     string
    ContactLast      string
    ContactEmail     string
    ContactPhone     string
    DeliveryDate     string
    RackLocation     string
    RackType         string
}

type OrderResult struct {
    OrderID string            `json:"order_id"`
    Status  map[string]string `json:"status"`
}

func main() {
    mode := flag.String("mode", "gcs", "Execution mode: local or gcs")
    checkAll := flag.Bool("check-status", false, "Check status of all orders")
    checkOne := flag.String("check-order-status", "", "Check status of a specific order")
    flag.Parse()

    ctx := context.Background()
    creds, err := google.FindDefaultCredentials(ctx, "https://www.googleapis.com/auth/cloud-platform")
    if err != nil {
        panic(err)
    }
    client := oauth2.NewClient(ctx, creds.TokenSource)
    gcsClient, err := storage.NewClient(ctx)
    if err != nil {
        panic(err)
    }

    if *checkAll {
        checkAllStatuses(ctx, client, gcsClient)
        return
    }
    if *checkOne != "" {
        checkOrderStatus(ctx, client, *checkOne)
        return
    }

    orders, err := readOrdersCSV(ctx, *mode, gcsClient)
    if err != nil {
        panic(err)
    }

    orderChan := make(chan OrderInfo)
    var wg sync.WaitGroup

    for i := 0; i < 5; i++ {
        go func() {
            for order := range orderChan {
                result := processOrderWithResult(order, client, ctx)
                saveOrderResult(ctx, *mode, order.OrderID, result, gcsClient)
                wg.Done()
            }
        }()
    }

    for _, o := range orders {
        wg.Add(1)
        orderChan <- o
    }
    close(orderChan)
    wg.Wait()
}

func readOrdersCSV(ctx context.Context, mode string, gcsClient *storage.Client) ([]OrderInfo, error) {
    var reader *csv.Reader
    if mode == "local" {
        f, err := os.Open(ordersCSV)
        if err != nil {
            return nil, err
        }
        defer f.Close()
        reader = csv.NewReader(f)
    } else {
        rc, err := gcsClient.Bucket(gcsBucket).Object(ordersCSV).NewReader(ctx)
        if err != nil {
            return nil, err
        }
        defer rc.Close()
        reader = csv.NewReader(rc)
    }

    reader.TrimLeadingSpace = true
    records, err := reader.ReadAll()
    if err != nil {
        return nil, err
    }

    var orders []OrderInfo
    for _, rec := range records[1:] {
        orders = append(orders, OrderInfo{
            OrderID:       rec[0],
            SiteID:        rec[1],
            SiteDisplay:   rec[2],
            SiteDesc:      rec[3],
            SiteAddress:   rec[4],
            SiteRep:       rec[5],
            SiteEmail:     rec[6],
            ZoneID:        rec[7],
            ZoneDisplay:   rec[8],
            HardwareID:    rec[9],
            SKU:           rec[10],
            OrderDisplay:  rec[11],
            CompanyName:   rec[12],
            CompanyEmail:  rec[13],
            CompanyPhone:  rec[14],
            ContactFirst:  rec[15],
            ContactLast:   rec[16],
            ContactEmail:  rec[17],
            ContactPhone:  rec[18],
            DeliveryDate:  rec[19],
            RackLocation:  rec[20],
            RackType:      rec[21],
        })
    }
    return orders, nil
}

func saveOrderResult(ctx context.Context, mode, orderID string, result OrderResult, gcsClient *storage.Client) {
    data, _ := json.MarshalIndent(result, "", "  ")
    if mode == "local" {
        os.WriteFile(orderID+"_result.json", data, 0644)
    } else {
        wc := gcsClient.Bucket(gcsBucket).Object(statePrefix + orderID + "_result.json").NewWriter(ctx)
        defer wc.Close()
        wc.Write(data)
    }
}

func processOrderWithResult(order OrderInfo, client *http.Client, ctx context.Context) OrderResult {
    result := OrderResult{
        OrderID: order.OrderID,
        Status:  make(map[string]string),
    }

    if createSite(order, client) {
        result.Status["site"] = "success"
    } else {
        result.Status["site"] = "failed"
        return result
    }

    if createZone(order, client) {
        result.Status["zone"] = "success"
    } else {
        result.Status["zone"] = "failed"
        return result
    }

    if createHardware(order, client) {
        result.Status["hardware"] = "success"
    } else {
        result.Status["hardware"] = "failed"
        return result
    }

    if createOrder(order, client) {
        result.Status["order"] = "success"
    } else {
        result.Status["order"] = "failed"
    }

    return result
}

func createSite(order OrderInfo, client *http.Client) bool {
    url := fmt.Sprintf("%s/projects/%s/locations/%s/sites?siteId=%s", apiBase, projectID, region, order.SiteID)
    payload := map[string]interface{}{
        "displayName": order.SiteDisplay,
        "description": order.SiteDesc,
        "contact": map[string]string{
            "givenName":  order.SiteRep,
            "familyName": "",
            "email":      order.SiteEmail,
            "phone":      "+1-000-000-0000",
        },
        "address": map[string]interface{}{
            "regionCode":         "US",
            "postalCode":         "10001",
            "administrativeArea": "NY",
            "locality":           "New York",
            "addressLines":       []string{order.SiteAddress},
        },
    }
    return doPost(client, url, payload)
}

func createZone(order OrderInfo, client *http.Client) bool {
    url := fmt.Sprintf("%s/projects/%s/locations/%s/zones?zoneId=%s", apiBase, projectID, region, order.ZoneID)
    payload := map[string]interface{}{
        "displayName":   order.ZoneDisplay,
        "site":          fmt.Sprintf("projects/%s/locations/%s/sites/%s", projectID, region, order.SiteID),
        "networkConfig": zoneNetworkConfig,
    }
    return doPost(client, url, payload)
}

func createHardware(order OrderInfo, client *http.Client) bool {
    url := fmt.Sprintf("%s/projects/%s/locations/%s/hardware?hardwareId=%s", apiBase, projectID, region, order.HardwareID)
    payload := map[string]interface{}{
        "displayName": order.HardwareID,
        "sku":         order.SKU,
        "zone":        fmt.Sprintf("projects/%s/locations/%s/zones/%s", projectID, region, order.ZoneID),
        "installationInfo": map[string]interface{}{
            "rack": map[string]interface{}{
                "location": order.RackLocation,
                "rackType": order.RackType,
            },
            "dimensions":        hardwareDefaults["dimensions"],
            "weight":            hardwareDefaults["weight"],
            "powerRequirements": hardwareDefaults["powerRequirements"],
        },
    }
    return doPost(client, url, payload)
}

func createOrder(order OrderInfo, client *http.Client) bool {
    url := fmt.Sprintf("%s/projects/%s/locations/%s/orders?orderId=%s", apiBase, projectID, region, order.OrderID)
    payload := map[string]interface{}{
        "displayName": order.OrderDisplay,
        "site":        fmt.Sprintf("projects/%s/locations/%s/sites/%s", projectID, region, order.SiteID),
        "zone":        fmt.Sprintf("projects/%s/locations/%s/zones/%s", projectID, region, order.ZoneID),
        "contact": map[string]string{
            "givenName":  order.ContactFirst,
            "familyName": order.ContactLast,
            "email":      order.ContactEmail,
            "phone":      order.ContactPhone,
        },
    }
    return doPost(client, url, payload)
}

func doPost(client *http.Client, url string, payload map[string]interface{}) bool {
    data, _ := json.Marshal(payload)
    req, _ := http.NewRequest("POST", url, bytes.NewBuffer(data))
    req.Header.Set("Content-Type", "application/json")
    resp, err := client.Do(req)
    if err != nil {
        fmt.Printf("❌ Request error: %v
", err)
        return false
    }
    defer resp.Body.Close()
    body, _ := ioutil.ReadAll(resp.Body)
    if resp.StatusCode >= 200 && resp.StatusCode < 300 {
        return true
    }
    fmt.Printf("❌ API error: %s
", string(body))
    return false
}

