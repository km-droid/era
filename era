package main

import (
	"context"
	"flag"
	"fmt"
	"log"

	// Newer Go client for Compute Engine
	compute "cloud.google.com/go/compute/apiv1"
	// Protobuf messages for the Compute Engine API
	computepb "cloud.google.com/go/compute/apiv1/computepb"
)

// Helper functions to simplify pointer creation
func stringPtr(s string) *string    { return &s }
func int64Ptr(i int64) *int64       { return &i }
func uint64Ptr(u uint64) *uint64    { return &u }
func float64Ptr(f float64) *float64 { return &f }

func main() {
	// Set up command-line flags
	projectID := flag.String("project", "", "GCP project ID")
	region := flag.String("region", "", "Region of the INTERNAL HTTP(S) LB (e.g., us-central1)")
	urlMapName := flag.String("urlmap", "", "Name of the regional URL map to patch")
	delaySeconds := flag.Int64("delay-seconds", 2, "Number of seconds to delay requests")
	delayPercentage := flag.Float64("delay-pct", 50, "Percentage of requests to delay")
	abortStatus := flag.Int64("abort-status", 503, "HTTP status code to inject")
	abortPercentage := flag.Float64("abort-pct", 10, "Percentage of requests to abort")

	// Flag to remove fault injection (rollback to default)
	rollbackDefault := flag.Bool("rollback-default", false, "If true, removes fault injection (revert to defaults)")

	flag.Parse()

	// Basic validation
	if *projectID == "" || *region == "" || *urlMapName == "" {
		log.Fatalf("You must provide --project, --region, and --urlmap flags.")
	}

	ctx := context.Background()

	// Create a RegionUrlMaps client (used for internal HTTP(S) LB in a specific region)
	urlMapClient, err := compute.NewRegionUrlMapsRESTClient(ctx)
	if err != nil {
		log.Fatalf("Failed to create RegionUrlMaps client: %v", err)
	}
	defer urlMapClient.Close()

	// Build the updated UrlMap resource
	updatedUrlMap := &computepb.UrlMap{
		Name: stringPtr(*urlMapName),
		DefaultRouteAction: &computepb.HttpRouteAction{
			// We'll conditionally set FaultInjectionPolicy below
		},
	}

	if *rollbackDefault {
		// Remove fault injection by omitting FaultInjectionPolicy
		log.Println("[INFO] Removing fault injection to revert the load balancer to default settings.")
	} else {
		// Apply fault injection with the given flags
		updatedUrlMap.DefaultRouteAction.FaultInjectionPolicy = &computepb.HttpRouteAction_FaultInjectionPolicy{
			Delay: &computepb.HttpRouteAction_FaultInjectionPolicy_Delay{
				FixedDelay: &computepb.Duration{
					Seconds: uint64Ptr(uint64(*delaySeconds)), // must be uint64
				},
				Percentage: float64Ptr(*delayPercentage),
			},
			Abort: &computepb.HttpRouteAction_FaultInjectionPolicy_Abort{
				HttpStatus: int64Ptr(*abortStatus),
				Percentage: float64Ptr(*abortPercentage),
			},
		}
		log.Printf("[INFO] Setting fault injection: %ds delay @ %.1f%%, HTTP %d errors @ %.1f%%",
			*delaySeconds, *delayPercentage, *abortStatus, *abortPercentage)
	}

	// Patch the existing regional URL map with our new or removed fault injection
	op, err := urlMapClient.Patch(ctx, &computepb.PatchRegionUrlMapRequest{
		Project:        *projectID,
		Region:         *region,
		UrlMap:         *urlMapName,
		UrlMapResource: updatedUrlMap,
	})
	if err != nil {
		log.Fatalf("Patch request failed: %v", err)
	}

	// Wait for the patch operation to complete
	if err := op.Wait(ctx); err != nil {
		log.Fatalf("Error while waiting for patch operation: %v", err)
	}

	if *rollbackDefault {
		fmt.Println("Successfully reverted URL map to default (no fault injection).")
	} else {
		fmt.Println("Successfully updated URL map with fault injection settings.")
	}
}
