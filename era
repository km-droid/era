package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"cloud.google.com/go/pubsub"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	corev1 "k8s.io/api/core/v1"
)

var (
	projectID      = "your-google-cloud-project-id"
	subscriptionID = "your-pubsub-subscription-id"
	kubeconfigPath = "/path/to/kubeconfig" // Optional: If you want to use a custom kubeconfig file
	namespace      = "default"             // Kubernetes namespace
	labelSelector  = "app=master"          // Label selector to find the master pod
)

type PubSubMessage struct {
	ScriptArgs map[string]string `json:"script_args"` // Assuming the JSON contains a map of arguments
}

func main() {
	// Set up Pub/Sub client
	ctx := context.Background()
	client, err := pubsub.NewClient(ctx, projectID)
	if err != nil {
		log.Fatalf("Failed to create Pub/Sub client: %v", err)
	}

	sub := client.Subscription(subscriptionID)

	// Set up Kubernetes client
	config, err := clientcmd.BuildConfigFromFlags("", kubeconfigPath)
	if err != nil {
		log.Fatalf("Failed to build Kubernetes config: %v", err)
	}

	kubeClient, err := kubernetes.NewForConfig(config)
	if err != nil {
		log.Fatalf("Failed to create Kubernetes client: %v", err)
	}

	// Receive messages from Pub/Sub
	err = sub.Receive(ctx, func(ctx context.Context, msg *pubsub.Message) {
		fmt.Printf("Received message: %s\n", string(msg.Data))
		msg.Ack()

		// Parse the JSON message
		var parsedMessage PubSubMessage
		if err := json.Unmarshal(msg.Data, &parsedMessage); err != nil {
			log.Printf("Failed to parse Pub/Sub message: %v", err)
			return
		}

		// Retrieve pod name dynamically based on label
		podName, err := getPodNameByLabel(kubeClient)
		if err != nil {
			log.Printf("Failed to get pod name: %v", err)
			return
		}

		fmt.Printf("Pod Name: %s\n", podName)

		// Trigger Kubernetes Job or execute command inside the master pod
		err = runShellScriptInMasterPod(kubeClient, podName, parsedMessage.ScriptArgs)
		if err != nil {
			log.Printf("Failed to trigger Kubernetes Job: %v", err)
		} else {
			log.Printf("Kubernetes Job triggered successfully.")
		}
	})

	if err != nil {
		log.Fatalf("Failed to receive Pub/Sub messages: %v", err)
	}
}

// getPodNameByLabel finds the pod by label selector and returns its name
func getPodNameByLabel(client *kubernetes.Clientset) (string, error) {
	// Get the list of pods in the specified namespace with the label selector
	pods, err := client.CoreV1().Pods(namespace).List(context.Background(), metav1.ListOptions{
		LabelSelector: labelSelector,
	})
	if err != nil {
		return "", fmt.Errorf("failed to list pods: %v", err)
	}

	if len(pods.Items) == 0 {
		return "", fmt.Errorf("no pods found with label %s", labelSelector)
	}

	// Return the first pod name
	return pods.Items[0].Name, nil
}

// runShellScriptInMasterPod executes a command inside the master pod using kubectl exec
func runShellScriptInMasterPod(client *kubernetes.Clientset, podName string, scriptArgs map[string]string) error {
	// Prepare the arguments to pass to the script
	args := ""
	for key, value := range scriptArgs {
		args += fmt.Sprintf("--%s=%s ", key, value)
	}

	// Prepare the command to run the shell script
	cmd := []string{"/bin/sh", "-c", "./master_script.sh " + args}

	// Execute the command inside the pod using kubectl exec
	execClient := client.CoreV1().Pods(namespace).GetExecClient()
	_, err := execClient.Pod(podName).Exec(
		cmd...).StreamOptions(metav1.StreamOptions{}).Execute()

	return err
}

====================================================



===========


apiVersion: apps/v1
kind: Deployment
metadata:
  name: pubsub-handler
  labels:
    app: pubsub-handler
spec:
  replicas: 1
  selector:
    matchLabels:
      app: pubsub-handler
  template:
    metadata:
      labels:
        app: pubsub-handler
    spec:
      containers:
        - name: pubsub-handler
          image: gcr.io/your-project-id/pubsub-handler:latest
          env:
            - name: GOOGLE_APPLICATION_CREDENTIALS
              value: /etc/gcloud/key.json
            - name: KUBECONFIG
              value: /etc/kubernetes/kubeconfig
          volumeMounts:
            - name: gcloud-key
              mountPath: /etc/gcloud
              readOnly: true
            - name: kubeconfig
              mountPath: /etc/kubernetes
              readOnly: true
      volumes:
        - name: gcloud-key
          secret:
            secretName: gcloud-service-account-key
        - name: kubeconfig
          secret:
            secretName: kubeconfig
---
apiVersion: v1
kind: Service
metadata:
  name: pubsub-handler
spec:
  selector:
    app: pubsub-handler
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080


===============================


apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  # Name of the role
  name: exec-pod
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["list", "get", "exec"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: exec-pod-binding
subjects:
  - kind: ServiceAccount
    name: pubsub-handler
    namespace: default
roleRef:
  kind: ClusterRole
  name: exec-pod
  apiGroup: rbac.authorization.k8s.io





