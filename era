package main

import (
	"context"
	"flag"
	"fmt"
	"log"

	compute "cloud.google.com/go/compute/apiv1"
	computepb "cloud.google.com/go/compute/apiv1/computepb"
)

// Pointer helpers
func stringPtr(s string) *string    { return &s }
func int64Ptr(i int64) *int64       { return &i }
func float64Ptr(f float64) *float64 { return &f }
func uint64Ptr(u uint64) *uint64    { return &u }

// UpdateILBUrlMapFaultInjection uses UpdateRegionUrlMap (rather than Patch)
// to either set or remove fault injection in a single, full overwrite.
func UpdateILBUrlMapFaultInjection(
	ctx context.Context,
	urlMapClient *compute.RegionUrlMapsClient,
	project, region, urlMap string,
	rollback bool, // if true, remove fault injection
	delaySeconds int64,
	delayPercentage float64,
	abortStatus int64,
	abortPercentage float64,
) error {

	// 1) Get the existing URL map resource
	existing, err := urlMapClient.Get(ctx, &computepb.GetRegionUrlMapRequest{
		Project: project,
		Region:  region,
		UrlMap:  urlMap,
	})
	if err != nil {
		return fmt.Errorf("failed to get existing URL map: %w", err)
	}

	if existing.DefaultRouteAction == nil {
		// Ensure DefaultRouteAction is not nil before modifying
		existing.DefaultRouteAction = &computepb.HttpRouteAction{}
	}

	if rollback {
		// 2a) Remove fault injection
		log.Println("[INFO] Rolling back to default by removing FaultInjectionPolicy.")
		existing.DefaultRouteAction.FaultInjectionPolicy = nil
	} else {
		// 2b) Apply new fault injection
		log.Printf("[INFO] Setting fault injection: %ds delay @ %.1f%%, HTTP %d errors @ %.1f%%",
			delaySeconds, delayPercentage, abortStatus, abortPercentage)

		existing.DefaultRouteAction.FaultInjectionPolicy = &computepb.HttpRouteAction_FaultInjectionPolicy{
			Delay: &computepb.HttpRouteAction_FaultInjectionPolicy_Delay{
				FixedDelay: &computepb.Duration{
					Seconds: uint64Ptr(uint64(delaySeconds)), // must be uint64
				},
				Percentage: float64Ptr(delayPercentage),
			},
			Abort: &computepb.HttpRouteAction_FaultInjectionPolicy_Abort{
				HttpStatus: int64Ptr(abortStatus),
				Percentage: float64Ptr(abortPercentage),
			},
		}
	}

	// 3) Update the URL map with the new (or removed) fault injection
	op, err := urlMapClient.Update(ctx, &computepb.UpdateRegionUrlMapRequest{
		Project:        project,
		Region:         region,
		UrlMap:         urlMap,
		UrlMapResource: existing,
	})
	if err != nil {
		return fmt.Errorf("update request failed: %w", err)
	}

	// 4) Wait for the update to complete
	if err := op.Wait(ctx); err != nil {
		return fmt.Errorf("error while waiting for update operation: %w", err)
	}

	if rollback {
		log.Println("[INFO] Successfully reverted URL map to default (no fault injection).")
	} else {
		log.Println("[INFO] Successfully updated URL map with new fault injection settings.")
	}
	return nil
}

// The main function that uses the helper
func main() {
	projectID := flag.String("project", "", "GCP project ID")
	region := flag.String("region", "", "Region of the INTERNAL HTTP(S) LB (e.g. us-central1)")
	urlMapName := flag.String("urlmap", "", "Name of the regional URL map to update")

	delaySeconds := flag.Int64("delay-seconds", 2, "Number of seconds to delay requests")
	delayPct := flag.Float64("delay-pct", 50, "Percentage of requests to delay")
	abortStatus := flag.Int64("abort-status", 503, "HTTP status code to inject")
	abortPct := flag.Float64("abort-pct", 10, "Percentage of requests to abort")

	rollbackDefault := flag.Bool("rollback-default", false, "Remove fault injection if true")

	flag.Parse()
	if *projectID == "" || *region == "" || *urlMapName == "" {
		log.Fatalf("You must provide --project, --region, and --urlmap flags.")
	}

	ctx := context.Background()
	urlMapClient, err := compute.NewRegionUrlMapsRESTClient(ctx)
	if err != nil {
		log.Fatalf("Failed to create RegionUrlMaps client: %v", err)
	}
	defer urlMapClient.Close()

	err = UpdateILBUrlMapFaultInjection(
		ctx,
		urlMapClient,
		*projectID,
		*region,
		*urlMapName,
		*rollbackDefault,
		*delaySeconds,
		*delayPct,
		*abortStatus,
		*abortPct,
	)
	if err != nil {
		log.Fatalf("Error updating fault injection: %v", err)
	}
}
