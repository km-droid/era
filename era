package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
)

var (
	gitModuleRe = regexp.MustCompile(`(?m)source\s*=\s*\"git::https://github.com/[^/]+/modules\.git//([^"?]+)(\?ref=[^\"]+)?\"`)
	moduleSourceRe = regexp.MustCompile(`(?m)source\s*=\s*\"registry\.terraform\.example\.com/org/([^/]+)/google\"`)
	moduleBlockRe  = regexp.MustCompile(`(?ms)(module\s+\"[^\"]+\"\s*\{[^}]*?source\s*=\s*\"registry\.terraform\.example\.com/org/[^\"]+/google\"[^}]*?)version\s*=\s*\"[^\"]+\"([^}]*?})`)
	updatedFiles []string
	mu sync.Mutex
	dryRun    bool
	showHelp  bool
)

func cloneRepo(repoName string) error {
	repoURL := fmt.Sprintf("git@github.com:your-org/%s.git", repoName)
	cmd := exec.Command("git", "clone", repoURL)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func collectTfFiles(repoPath string) ([]string, error) {
	var tfFiles []string
	err := filepath.WalkDir(repoPath, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(d.Name(), ".tf") {
			tfFiles = append(tfFiles, path)
		}
		return nil
	})
	return tfFiles, err
}

func transformGitSourceToRegistry(content string, versionConstraint string) string {
	// Replace old git-based source with registry source and add version line
	lines := strings.Split(content, "\n")
	for i, line := range lines {
		matches := gitModuleRe.FindStringSubmatch(line)
		if matches != nil {
			moduleName := matches[1] // e.g., "gclb"
			sourceLine := fmt.Sprintf("  source  = \"registry.terraform.example.com/org/%s/google\"", moduleName)
			versionLine := fmt.Sprintf("  version = \"%s\"", versionConstraint)
			lines[i] = sourceLine + "\n" + versionLine
		}
	}
	return strings.Join(lines, "\n")
}

func updateModuleVersion(content string, versionConstraint string) string {
	content = transformGitSourceToRegistry(content, versionConstraint)
	if moduleBlockRe.MatchString(content) {
		return moduleBlockRe.ReplaceAllString(content, `$1version = ""`+versionConstraint+`"$2`)
	}

	// Add version line if module block has a source but no version
	lines := strings.Split(content, "\n")
	for i, line := range lines {
		matches := moduleSourceRe.FindStringSubmatch(line)
		if matches != nil {
			versionLine := fmt.Sprintf("  version = \"%s\"", versionConstraint)
			lines[i] = line + "\n" + versionLine
		}
	}
	return strings.Join(lines, "\n")
}

func processFile(path string, versionConstraint string, wg *sync.WaitGroup) {
	defer wg.Done()
	input, err := ioutil.ReadFile(path)
	if err != nil {
		fmt.Printf("‚ùå Failed to read %s: %v\n", path, err)
		return
	}

	content := string(input)
	updated := updateModuleVersion(content, versionConstraint)

	if updated != content {
		if dryRun {
			fmt.Printf("üîç Would update: %s\n", path)
		} else {
			err := ioutil.WriteFile(path, []byte(updated), 0644)
			if err != nil {
				fmt.Printf("‚ùå Failed to write %s: %v\n", path, err)
				return
			}
			fmt.Printf("‚úÖ Updated: %s\n", path)
			mu.Lock()
			updatedFiles = append(updatedFiles, path)
			mu.Unlock()
		}
	}
}

func updateModulesConcurrently(repoPath string, versionConstraint string) error {
	tfFiles, err := collectTfFiles(repoPath)
	if err != nil {
		return err
	}

	var wg sync.WaitGroup
	sem := make(chan struct{}, 8)

	for _, path := range tfFiles {
		wg.Add(1)
		sem <- struct{}{}
		go func(p string) {
			defer func() { <-sem }()
			processFile(p, versionConstraint, &wg)
		}(path)
	}

	wg.Wait()
	return nil
}

func createPR(repoName, branchName string) (string, error) {
	repoDir := filepath.Base(repoName)
	if err := os.Chdir(repoDir); err != nil {
		return "", err
	}

	cmds := [][]string{
		{"git", "checkout", "-b", branchName},
		{"git", "add", "."},
		{"git", "commit", "-m", "Update Terraform module version constraints"},
		{"git", "push", "--set-upstream", "origin", branchName},
	}

	for _, args := range cmds {
		cmd := exec.Command(args[0], args[1:]...)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			return "", err
		}
	}

	prURL := fmt.Sprintf("https://github.com/your-org/%s/compare/main...%s", repoName, branchName)
	return prURL, nil
}

func printUsage() {
	fmt.Println("Usage: terraform-module-migrator [options] <repo-name>")
	fmt.Println("\nOptions:")
	fmt.Println("  --dry-run\t	Preview changes without modifying files")
	fmt.Println("  --version=<v>\tModule version constraint (e.g., 2.0 or ~> 2.0)")
	fmt.Println("  --help\t\tShow this help message")
}

func main() {
	var moduleVersionRaw string
	flag.BoolVar(&dryRun, "dry-run", false, "Preview changes without modifying files")
	flag.BoolVar(&showHelp, "help", false, "Show help message")
	flag.StringVar(&moduleVersionRaw, "version", "1.0", "Module version constraint (e.g., 2.0 or ~> 2.0)")
	flag.Parse()

	if showHelp || flag.NArg() < 1 {
		printUsage()
		os.Exit(0)
	}

	versionConstraint := moduleVersionRaw
	if !strings.HasPrefix(versionConstraint, "~") {
		versionConstraint = fmt.Sprintf("~> %s", moduleVersionRaw)
	}

	repo := flag.Arg(0)
	branch := fmt.Sprintf("update-module-version-%s", strings.ReplaceAll(moduleVersionRaw, ".", "-"))

	if err := cloneRepo(repo); err != nil {
		fmt.Printf("‚ùå Failed to clone repo: %v\n", err)
		os.Exit(1)
	}

	repoPath := filepath.Join(".", filepath.Base(repo))
	if err := updateModulesConcurrently(repoPath, versionConstraint); err != nil {
		fmt.Printf("‚ùå Failed to update modules: %v\n", err)
		os.Exit(1)
	}

	if dryRun {
		fmt.Println("üîç Dry run complete.")
		fmt.Printf("üîç Files that would be updated: %d\n", len(updatedFiles))
		for _, f := range updatedFiles {
			fmt.Println("üîç", f)
		}
		return
	}

	prURL, err := createPR(repo, branch)
	if err != nil {
		fmt.Printf("‚ùå Failed to create PR: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("‚úÖ Version update completed. Total files updated: %d\n", len(updatedFiles))
	for _, f := range updatedFiles {
		fmt.Println("‚úÖ", f)
	}
	fmt.Printf("üîó PR created: %s\n", prURL)
}
