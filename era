package ui

import (
	"chaoscli/actions"
	"chaoscli/cloudrun"
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
)

type state int

const (
	selectProject state = iota
	selectService
	selectRevision
	selectChaos
	selectFault
	done
)

type item string

func (i item) FilterValue() string { return string(i) }

type model struct {
	state        state
	projectList  list.Model
	serviceList  list.Model
	revisionList list.Model
	selectedProj string
	selectedSvc  string
	selectedRev  string
	chaosMenu    menuModel
	faultMenu    menuModel
}

func InitialModel() model {
	projects, err := cloudrun.LoadProjectsFromGCS()
	if err != nil {
		panic(err)
	}
	var items []list.Item
	for _, p := range projects {
		items = append(items, item(p))
	}
	l := list.New(items, list.NewDefaultDelegate(), 50, 20)
	l.Title = "Select a GCP Project"
	return model{state: selectProject, projectList: l}
}

func (m model) Init() tea.Cmd {
	return nil
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch m.state {
	case selectProject:
		var cmd tea.Cmd
		m.projectList, cmd = m.projectList.Update(msg)
		if key, ok := msg.(tea.KeyMsg); ok && key.String() == "enter" {
			if i, ok := m.projectList.SelectedItem().(item); ok {
				m.selectedProj = string(i)
				m.state = selectService

				services, err := cloudrun.ListCloudRunServices(m.selectedProj)
				if err != nil {
					panic(err)
				}
				var items []list.Item
				for _, s := range services {
					items = append(items, item(s))
				}
				m.serviceList = list.New(items, list.NewDefaultDelegate(), 50, 20)
				m.serviceList.Title = "Select Cloud Run Service"
			}
		}
		return m, cmd

	case selectService:
		var cmd tea.Cmd
		m.serviceList, cmd = m.serviceList.Update(msg)
		if key, ok := msg.(tea.KeyMsg); ok && key.String() == "enter" {
			if i, ok := m.serviceList.SelectedItem().(item); ok {
				m.selectedSvc = string(i)
				m.state = selectRevision

				revisions, err := cloudrun.ListRevisionsWithTraffic(m.selectedProj, m.selectedSvc)
				if err != nil {
					panic(err)
				}
				var items []list.Item
				for _, r := range revisions {
					items = append(items, item(r))
				}
				m.revisionList = list.New(items, list.NewDefaultDelegate(), 50, 20)
				m.revisionList.Title = "Select Revision"
			}
		}
		return m, cmd

	case selectRevision:
		var cmd tea.Cmd
		m.revisionList, cmd = m.revisionList.Update(msg)
		if key, ok := msg.(tea.KeyMsg); ok && key.String() == "enter" {
			if i, ok := m.revisionList.SelectedItem().(item); ok {
				m.selectedRev = string(i)
				m.state = selectChaos
				m.chaosMenu = newMenu("Choose chaos action", []string{"Bring down service", "Inject fault"})
			}
		}
		return m, cmd

	case selectChaos:
		var cmd tea.Cmd
		m.chaosMenu, cmd = m.chaosMenu.Update(msg)
		if m.chaosMenu.Confirmed() {
			if m.chaosMenu.SelectedIndex() == 0 {
				actions.LogChaosAction(m.selectedProj, m.selectedSvc, m.selectedRev, "Bring down service")
				m.state = done
			} else {
				m.faultMenu = newMenu("Select Fault Type", []string{"Add Delay", "Return 5xx", "Return 4xx"})
				m.state = selectFault
			}
		}
		return m, cmd

	case selectFault:
		var cmd tea.Cmd
		m.faultMenu, cmd = m.faultMenu.Update(msg)
		if m.faultMenu.Confirmed() {
			actions.LogChaosAction(m.selectedProj, m.selectedSvc, m.selectedRev, m.faultMenu.Selected())
			m.state = done
		}
		return m, cmd

	case done:
		return m, tea.Quit
	}
	return m, nil
}

func (m model) View() string {
	switch m.state {
	case selectProject:
		return m.projectList.View()
	case selectService:
		return m.serviceList.View()
	case selectRevision:
		return m.revisionList.View()
	case selectChaos:
		return m.chaosMenu.View()
	case selectFault:
		return m.faultMenu.View()
	case done:
		return "\n✅ Chaos action logged. Exiting.\n"
	}
	return "Loading..."
}

// Menu selector

type menuModel struct {
	title   string
	options []string
	cursor  int
	choice  int
	confirm bool
}

func newMenu(title string, options []string) menuModel {
	return menuModel{title: title, options: options, cursor: 0, confirm: false}
}

func (m menuModel) Update(msg tea.Msg) (menuModel, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "up", "k":
			if m.cursor > 0 {
				m.cursor--
			}
		case "down", "j":
			if m.cursor < len(m.options)-1 {
				m.cursor++
			}
		case "enter":
			m.choice = m.cursor
			m.confirm = true
		}
	}
	return m, nil
}

func (m menuModel) View() string {
	var b strings.Builder
	b.WriteString(m.title + "\n\n")
	for i, opt := range m.options {
		cursor := "  "
		if m.cursor == i {
			cursor = "➜ "
		}
		b.WriteString(fmt.Sprintf("%s%s\n", cursor, opt))
	}
	return b.String()
}

func (m menuModel) Confirmed() bool    { return m.confirm }
func (m menuModel) Selected() string   { return m.options[m.choice] }
func (m menuModel) SelectedIndex() int { return m.choice }
